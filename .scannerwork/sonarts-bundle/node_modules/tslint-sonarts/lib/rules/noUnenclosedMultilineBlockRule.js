"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * SonarTS
 * Copyright (C) 2017-2017 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const navigation_1 = require("../utils/navigation");
const tslint = require("tslint");
const ts = require("typescript");
class Rule extends tslint.Rules.AbstractRule {
    apply(sourceFile) {
        return this.applyWithWalker(new Walker(sourceFile, this.getOptions()));
    }
}
Rule.metadata = {
    description: "Multiline blocks should be enclosed in curly braces",
    options: null,
    optionsDescription: "",
    rspecKey: "RSPEC-2681",
    ruleName: "no-unenclosed-multiline-block",
    type: "functionality",
    typescriptOnly: false,
};
exports.Rule = Rule;
class Walker extends tslint.RuleWalker {
    visitBlock(node) {
        this.visitStatements(node.statements);
        super.visitBlock(node);
    }
    visitSourceFile(node) {
        this.visitStatements(node.statements);
        super.visitSourceFile(node);
    }
    visitModuleDeclaration(node) {
        if (node.body && node.body.kind === ts.SyntaxKind.ModuleBlock) {
            this.visitStatements(node.body.statements);
        }
        super.visitModuleDeclaration(node);
    }
    visitStatements(statements) {
        this.chain(statements)
            .filter(chainedStatements => chainedStatements.areUnenclosed())
            .forEach(unenclosedConsecutives => {
            if (unenclosedConsecutives.areAdjacent()) {
                this.raiseAdjacenceIssue(unenclosedConsecutives);
            }
            else if (unenclosedConsecutives.areBothIndented()) {
                this.raiseBlockIssue(unenclosedConsecutives, this.countStatementsInTheSamePile(unenclosedConsecutives.prev, statements));
            }
            else if (unenclosedConsecutives.areInlinedAndIndented()) {
                this.raiseInlinedAndIndentedIssue(unenclosedConsecutives);
            }
        });
    }
    chain(statements) {
        return statements
            .reduce((result, statement, i, array) => {
            if (i < array.length - 1) {
                if (this.isConditionOrLoop(statement)) {
                    result.push({ prev: statement, next: array[i + 1] });
                }
            }
            return result;
        }, new Array())
            .map(pair => {
            return new ChainedStatements(pair.prev, this.extractLastBody(pair.prev), pair.next, this);
        });
    }
    isConditionOrLoop(statement) {
        return navigation_1.is(statement, ts.SyntaxKind.IfStatement, ts.SyntaxKind.ForStatement, ts.SyntaxKind.ForInStatement, ts.SyntaxKind.ForOfStatement, ts.SyntaxKind.WhileStatement);
    }
    extractLastBody(statement) {
        if (statement.kind === ts.SyntaxKind.IfStatement) {
            if (!statement.elseStatement) {
                return statement.thenStatement;
            }
            else {
                return statement.elseStatement;
            }
        }
        else {
            return statement.statement;
        }
    }
    countStatementsInTheSamePile(reference, statements) {
        let startOfPile = this.getLineAndCharacterOfPosition(reference.getStart());
        let lastLineOfPile = startOfPile.line;
        for (const statement of statements) {
            const currentLine = this.getLineAndCharacterOfPosition(statement.getEnd()).line;
            const currentIndentation = this.getLineAndCharacterOfPosition(statement.getStart()).character;
            if (currentLine > startOfPile.line) {
                if (currentIndentation === startOfPile.character) {
                    lastLineOfPile = this.getLineAndCharacterOfPosition(statement.getEnd()).line;
                }
                else {
                    break;
                }
            }
        }
        return lastLineOfPile - startOfPile.line + 1;
    }
    raiseAdjacenceIssue(adjacentStatements) {
        this.addFailureAtNode(adjacentStatements.next, `This statement will not be executed ${adjacentStatements.includedStatementQualifier()}; ` +
            `only the first statement will be. The rest will execute ${adjacentStatements.excludedStatementsQualifier()}.`);
    }
    raiseBlockIssue(piledStatements, sizeOfPile) {
        this.addFailureAtNode(piledStatements.next, `This line will not be executed ${piledStatements.includedStatementQualifier()}; ` +
            `only the first line of this ${sizeOfPile}-line block will be. The rest will execute ${piledStatements.excludedStatementsQualifier()}.`);
    }
    raiseInlinedAndIndentedIssue(chainedStatements) {
        this.addFailureAtNode(chainedStatements.next, `This line will not be executed ${chainedStatements.includedStatementQualifier()}; ` +
            `only the first statement will be. The rest will execute ${chainedStatements.excludedStatementsQualifier()}.`);
    }
}
class ChainedStatements {
    constructor(topStatement, prev, next, walker) {
        this.topStatement = topStatement;
        this.prev = prev;
        this.next = next;
        this.positions = {
            prevTopStart: walker.getLineAndCharacterOfPosition(this.topStatement.getStart()),
            prevTopEnd: walker.getLineAndCharacterOfPosition(this.topStatement.getEnd()),
            prevStart: walker.getLineAndCharacterOfPosition(this.prev.getStart()),
            prevEnd: walker.getLineAndCharacterOfPosition(this.prev.getEnd()),
            nextStart: walker.getLineAndCharacterOfPosition(this.next.getStart()),
            nextEnd: walker.getLineAndCharacterOfPosition(this.next.getEnd()),
        };
    }
    areUnenclosed() {
        return this.prev.kind !== ts.SyntaxKind.Block;
    }
    areAdjacent() {
        return this.positions.prevEnd.line === this.positions.nextStart.line;
    }
    areBothIndented() {
        return this.positions.prevStart.character === this.positions.nextStart.character && this.prevIsIndented();
    }
    areInlinedAndIndented() {
        return (this.positions.prevStart.line === this.positions.prevTopEnd.line &&
            this.positions.nextStart.character > this.positions.prevTopStart.character);
    }
    includedStatementQualifier() {
        return this.topStatement.kind === ts.SyntaxKind.IfStatement ? "conditionally" : "in a loop";
    }
    excludedStatementsQualifier() {
        return this.topStatement.kind === ts.SyntaxKind.IfStatement ? "unconditionally" : "only once";
    }
    prevIsIndented() {
        return this.positions.prevStart.character > this.positions.prevTopStart.character;
    }
}
//# sourceMappingURL=noUnenclosedMultilineBlockRule.js.map