"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * SonarTS
 * Copyright (C) 2017-2017 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const tslint = require("tslint");
const ts = require("typescript");
const navigation_1 = require("../utils/navigation");
const builder_1 = require("../symbols/builder");
const table_1 = require("../symbols/table");
class Rule extends tslint.Rules.TypedRule {
    applyWithProgram(sourceFile, program) {
        const symbols = builder_1.SymbolTableBuilder.build(sourceFile, program);
        // walker is created to only save issues
        const walker = new tslint.RuleWalker(sourceFile, this.getOptions());
        // prettier-ignore
        symbols
            .getSymbols()
            .filter(symbol => Rule.hasCollectionType(symbol, program.getTypeChecker(), symbols))
            .filter(symbol => symbols.allUsages(symbol).length > 1)
            .map(symbol => ({ declaration: Rule.findDeclarationNode(symbol, symbols), symbol }))
            .filter(symbolAndDeclaration => symbolAndDeclaration.declaration)
            .map(symbolAndDeclaration => symbolAndDeclaration)
            .filter(symbolAndDeclaration => !navigation_1.firstAncestor(symbolAndDeclaration.declaration, [ts.SyntaxKind.Parameter, ts.SyntaxKind.ImportDeclaration]) &&
            !Rule.isExported(symbolAndDeclaration.declaration))
            .filter(symbolAndDeclaration => {
            // prettier-ignore
            const varDeclaration = navigation_1.firstAncestor(symbolAndDeclaration.declaration, [ts.SyntaxKind.VariableDeclaration]);
            if (varDeclaration) {
                if (navigation_1.is(varDeclaration.parent.parent, ts.SyntaxKind.ForInStatement, ts.SyntaxKind.ForOfStatement)) {
                    return false;
                }
                return !varDeclaration.initializer || Rule.isNewCollectionCreation(varDeclaration.initializer);
            }
            return true;
        })
            .filter(symbolAndDeclaration => !symbols.allUsages(symbolAndDeclaration.symbol).some(usage => Rule.isReadUsage(usage)))
            .forEach(symbolAndDeclaration => walker.addFailureAtNode(symbolAndDeclaration.declaration, Rule.MESSAGE));
        return walker.getFailures();
    }
    static isExported(declaration) {
        const varStatement = navigation_1.firstAncestor(declaration, [ts.SyntaxKind.VariableStatement]);
        return !!varStatement && navigation_1.is(varStatement.getFirstToken(), ts.SyntaxKind.ExportKeyword);
    }
    static isReadUsage(usage) {
        if (usage.is(table_1.UsageFlag.DECLARATION)) {
            return false;
        }
        // prettier-ignore
        const expressionStatement = navigation_1.firstAncestor(usage.node, [ts.SyntaxKind.ExpressionStatement]);
        if (expressionStatement) {
            return !Rule.WRITE_ARRAY_PATTERNS.some(pattern => pattern(expressionStatement, usage));
        }
        return true;
    }
    // myArray = [1, 2];
    static isVariableWrite(statement, usage) {
        if (navigation_1.is(statement.expression, ts.SyntaxKind.BinaryExpression)) {
            const binaryExpression = statement.expression;
            return (navigation_1.is(binaryExpression.operatorToken, ts.SyntaxKind.EqualsToken) &&
                binaryExpression.left === usage.node &&
                Rule.isNewCollectionCreation(binaryExpression.right));
        }
        return false;
    }
    // myArray[1] = 42;
    // myArray[1] += 42;
    static isElementWrite(statement, usage) {
        if (navigation_1.is(statement.expression, ts.SyntaxKind.BinaryExpression)) {
            const binaryExpression = statement.expression;
            if (navigation_1.is(binaryExpression.operatorToken, ts.SyntaxKind.EqualsToken, ...navigation_1.COMPOUND_ASSIGNMENTS) &&
                navigation_1.is(binaryExpression.left, ts.SyntaxKind.ElementAccessExpression)) {
                return binaryExpression.left.expression === usage.node;
            }
        }
        return false;
    }
    // myArray.push(1);
    static isWritingMethodCall(statement, usage) {
        const writingMethods = new Set([
            "copyWithin",
            "fill",
            "pop",
            "push",
            "reverse",
            "shift",
            "sort",
            "splice",
            "unshift",
            "clear",
            "delete",
            "set",
            "add",
        ]);
        if (navigation_1.is(statement.expression, ts.SyntaxKind.CallExpression)) {
            const callExpression = statement.expression;
            if (navigation_1.is(callExpression.expression, ts.SyntaxKind.PropertyAccessExpression)) {
                const propertyAccess = callExpression.expression;
                return propertyAccess.expression === usage.node && writingMethods.has(propertyAccess.name.text);
            }
        }
        return false;
    }
    static findDeclarationNode(symbol, symbols) {
        const declarationUsage = symbols.allUsages(symbol).find(usage => usage.is(table_1.UsageFlag.DECLARATION));
        if (!declarationUsage) {
            return null;
        }
        return declarationUsage.node;
    }
    static hasCollectionType(symbol, typeChecker, symbols) {
        const usage = symbols.allUsages(symbol)[0];
        const type = typeChecker.getTypeAtLocation(usage.node);
        if (type.symbol) {
            const typeName = type.symbol.name;
            return Rule.isCollectionName(typeName);
        }
        return false;
    }
    static isNewCollectionCreation(node) {
        if (navigation_1.is(node, ts.SyntaxKind.ArrayLiteralExpression)) {
            return true;
        }
        if (navigation_1.is(node, ts.SyntaxKind.CallExpression)) {
            return node.expression.getText() === "Array";
        }
        if (navigation_1.is(node, ts.SyntaxKind.NewExpression)) {
            const constructorName = node.expression.getText();
            return Rule.isCollectionName(constructorName);
        }
        return false;
    }
    static isCollectionName(str) {
        const collections = new Set([
            "Array",
            "Int8Array",
            "Uint8Array",
            "Uint8ClampedArray",
            "Int16Array",
            "Uint16Array",
            "Int32Array",
            "Uint32Array",
            "Float32Array",
            "Float64Array",
            "Set",
            "Map",
            "WeakSet",
            "WeakMap",
        ]);
        return collections.has(str);
    }
}
Rule.metadata = {
    ruleName: "no-unused-array",
    description: "Array contents should be used",
    optionsDescription: "",
    options: null,
    rspecKey: "RSPEC-4030",
    type: "maintainability",
    typescriptOnly: false,
};
Rule.WRITE_ARRAY_PATTERNS = [
    Rule.isElementWrite,
    Rule.isVariableWrite,
    Rule.isWritingMethodCall,
];
Rule.MESSAGE = "Either use this collection's contents or remove the collection.";
exports.Rule = Rule;
//# sourceMappingURL=noUnusedArrayRule.js.map